// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

function mapMaybe(f, maybe) {
  return Belt_Option.map(maybe, f);
}

var wsRe = (/[\n\t ]+/gm);

var commentRe = (/#.*$/gm);

function stripComments(param) {
  return param.replace(commentRe, "");
}

var seqRe = (/->/g);

var parRe = (/\|\|/g);

var ternaryRe = (/[\?\:]/);

function cleanup(code) {
  return code.replace(commentRe, "").replace(wsRe, " ").trim();
}

function parTokenize(code) {
  return $$Array.to_list(code.split(parRe));
}

function seqTokenize(code) {
  return $$Array.to_list(code.trim().split(seqRe));
}

function makeStep(s) {
  var parts = $$Array.to_list(s.split(ternaryRe));
  var exit = 0;
  if (parts) {
    var match = parts[1];
    var s$1 = parts[0];
    if (match) {
      var match$1 = match[1];
      if (match$1 && !match$1[1]) {
        return /* CondStep */Block.__(1, [
                  s$1.trim(),
                  makeStep(match[0]),
                  makeStep(match$1[0])
                ]);
      } else {
        exit = 1;
      }
    } else {
      return /* Step */Block.__(0, [
                s$1.trim(),
                s$1.trim()
              ]);
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    return /* Step */Block.__(0, [
              s.trim(),
              s.trim()
            ]);
  }
  
}

function par2flow(par) {
  if (par) {
    if (par[1]) {
      return /* Parallel */Block.__(3, [List.map((function (s) {
                        return seq2flow(seqTokenize(s));
                      }), par)]);
    } else {
      return makeStep(par[0]);
    }
  } else {
    return /* Noop */0;
  }
}

function seq2flow(seq) {
  if (seq) {
    var acc = seq[1];
    var s = seq[0];
    if (acc) {
      return /* Sequence */Block.__(2, [
                par2flow($$Array.to_list(s.split(parRe))),
                seq2flow(acc)
              ]);
    } else {
      return makeStep(s);
    }
  } else {
    return /* Noop */0;
  }
}

function parseFlow(input) {
  return seq2flow(seqTokenize(cleanup(input)));
}

function parseDefinition(input) {
  var parts = $$Array.to_list(cleanup(input).split("="));
  if (parts) {
    var match = parts[1];
    if (match && !match[1]) {
      return /* Definition */[
              parts[0],
              seq2flow(seqTokenize(cleanup(match[0])))
            ];
    } else {
      return undefined;
    }
  }
  
}

function parsePara(input) {
  return List.fold_left((function (acc, optdef) {
                if (optdef !== undefined) {
                  return List.append(acc, /* :: */[
                              optdef,
                              /* [] */0
                            ]);
                } else {
                  return acc;
                }
              }), /* [] */0, List.map(parseDefinition, $$Array.to_list(cleanup(input).split(";"))));
}

var FlowParser = /* module */[
  /* wsRe */wsRe,
  /* commentRe */commentRe,
  /* stripComments */stripComments,
  /* seqRe */seqRe,
  /* parRe */parRe,
  /* ternaryRe */ternaryRe,
  /* cleanup */cleanup,
  /* parTokenize */parTokenize,
  /* seqTokenize */seqTokenize,
  /* makeStep */makeStep,
  /* par2flow */par2flow,
  /* seq2flow */seq2flow,
  /* parseFlow */parseFlow,
  /* parseDefinition */parseDefinition,
  /* parsePara */parsePara
];

exports.mapMaybe = mapMaybe;
exports.FlowParser = FlowParser;
/* wsRe Not a pure module */
