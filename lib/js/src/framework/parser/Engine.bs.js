// Generated by BUCKLESCRIPT VERSION 4.0.14, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Infix$Iconixfw = require("./Infix.bs.js");
var Types$Iconixfw = require("../../types/Types.bs.js");
var Parser$Iconixfw = require("./Parser.bs.js");
var DefMapper$Iconixfw = require("./DefMapper.bs.js");

function mapMaybe(f, maybe) {
  return Belt_Option.map(maybe, f);
}

function logPre(name, x) {
  console.log(/* tuple */[
        "[" + (name + " input]"),
        x
      ]);
  return /* () */0;
}

function logPost(name, x) {
  console.log(/* tuple */[
        "[" + (name + " output]"),
        x
      ]);
  return /* () */0;
}

function Make(Dom) {
  var partial_arg = Dom[/* mapper */5];
  var defmapper = function (param) {
    return DefMapper$Iconixfw.mapDefinition(partial_arg, param);
  };
  var instantiate = function (def) {
    var maybe = Parser$Iconixfw.FlowParser[/* parseDefinition */13](def);
    return Belt_Option.map(maybe, defmapper);
  };
  var tap = function (f, x) {
    Curry._1(f, x);
    return x;
  };
  var ftap = function (f, futval) {
    return Infix$Iconixfw.$less$$great(futval, (function (param) {
                  Curry._1(f, param);
                  return param;
                }));
  };
  var beforeHook = function (name) {
    var partial_arg = Curry._1(Dom[/* tapStepBefore */1], name);
    return (function (param) {
        Curry._1(partial_arg, param);
        return param;
      });
  };
  var afterHook = function (name) {
    var partial_arg = Curry._1(Dom[/* tapStepAfter */2], name);
    return (function (param) {
        return Infix$Iconixfw.$less$$great(param, (function (param) {
                      return tap(partial_arg, param);
                    }));
      });
  };
  var execStep = function (name, stepFunc, data) {
    var partial_arg = Curry._1(Dom[/* tapStepAfter */2], name);
    var partial_arg$1 = Curry._1(Dom[/* tapStepBefore */1], name);
    return (function (param) {
                return ftap(partial_arg, param);
              })(Curry._1(stepFunc, (function (param) {
                        return tap(partial_arg$1, param);
                      })(data)));
  };
  var execFlow = function (flow) {
    if (typeof flow === "number") {
      return Types$Iconixfw.fresolve;
    } else {
      switch (flow.tag | 0) {
        case 0 : 
            var s = flow[1];
            var name = flow[0];
            return (function (param) {
                return execStep(name, s, param);
              });
        case 1 : 
            var right = flow[2];
            var left = flow[1];
            var cond = flow[0];
            return (function (param) {
                return execCondStep(cond, left, right, param);
              });
        case 2 : 
            var right$1 = flow[1];
            var left$1 = flow[0];
            return (function (param) {
                return execSeq(left$1, right$1, param);
              });
        case 3 : 
            var partial_arg = flow[0];
            return (function (param) {
                return execPar(partial_arg, param);
              });
        
      }
    }
  };
  var execCondStep = function (cond, left, right, data) {
    var match = Curry._2(Dom[/* evalPredicate */4], cond, data);
    var fl = match ? left : right;
    return execFlow(fl)(data);
  };
  var execSeq = function (left, right, data) {
    return Infix$Iconixfw.$great$great$eq(execFlow(left)(data), execFlow(right));
  };
  var execPar = function (flows, data) {
    return Curry._1(Dom[/* fold */6], execFlowList(flows, data));
  };
  var execFlowList = function (flowList, data) {
    return List.map((function (__x) {
                  return execFlow(__x)(data);
                }), flowList);
  };
  var exec = function (instance, data) {
    return execFlow(instance[1])(data);
  };
  var runnerGet = function (def) {
    var maybe = instantiate(def);
    return Belt_Option.map(maybe, exec);
  };
  var run = function (def, data) {
    var maybe = instantiate(def);
    var maybe$1 = Belt_Option.map(maybe, exec);
    var x = Belt_Option.map(maybe$1, (function (runFunc) {
            return Curry._1(runFunc, data);
          }));
    if (x !== undefined) {
      return Caml_option.valFromOption(x);
    } else {
      return Types$Iconixfw.freject("Unknown error");
    }
  };
  return /* module */[
          /* defmapper */defmapper,
          /* instantiate */instantiate,
          /* tap */tap,
          /* ftap */ftap,
          /* beforeHook */beforeHook,
          /* afterHook */afterHook,
          /* execStep */execStep,
          /* execFlow */execFlow,
          /* execCondStep */execCondStep,
          /* execSeq */execSeq,
          /* execPar */execPar,
          /* execFlowList */execFlowList,
          /* exec */exec,
          /* runnerGet */runnerGet,
          /* run */run
        ];
}

function MakeLink(Domain1) {
  return (function (Domain2) {
      var partial_arg = Domain1[/* mapper */5];
      var defmapper = function (param) {
        return DefMapper$Iconixfw.mapDefinition(partial_arg, param);
      };
      var instantiate = function (def) {
        var maybe = Parser$Iconixfw.FlowParser[/* parseDefinition */13](def);
        return Belt_Option.map(maybe, defmapper);
      };
      var tap = function (f, x) {
        Curry._1(f, x);
        return x;
      };
      var ftap = function (f, futval) {
        return Infix$Iconixfw.$less$$great(futval, (function (param) {
                      Curry._1(f, param);
                      return param;
                    }));
      };
      var beforeHook = function (name) {
        var partial_arg = Curry._1(Domain1[/* tapStepBefore */1], name);
        return (function (param) {
            Curry._1(partial_arg, param);
            return param;
          });
      };
      var afterHook = function (name) {
        var partial_arg = Curry._1(Domain1[/* tapStepAfter */2], name);
        return (function (param) {
            return Infix$Iconixfw.$less$$great(param, (function (param) {
                          return tap(partial_arg, param);
                        }));
          });
      };
      var execStep = function (name, stepFunc, data) {
        var partial_arg = Curry._1(Domain1[/* tapStepAfter */2], name);
        var partial_arg$1 = Curry._1(Domain1[/* tapStepBefore */1], name);
        return (function (param) {
                    return ftap(partial_arg, param);
                  })(Curry._1(stepFunc, (function (param) {
                            return tap(partial_arg$1, param);
                          })(data)));
      };
      var execFlow = function (flow) {
        if (typeof flow === "number") {
          return Types$Iconixfw.fresolve;
        } else {
          switch (flow.tag | 0) {
            case 0 : 
                var s = flow[1];
                var name = flow[0];
                return (function (param) {
                    return execStep(name, s, param);
                  });
            case 1 : 
                var right = flow[2];
                var left = flow[1];
                var cond = flow[0];
                return (function (param) {
                    return execCondStep(cond, left, right, param);
                  });
            case 2 : 
                var right$1 = flow[1];
                var left$1 = flow[0];
                return (function (param) {
                    return execSeq(left$1, right$1, param);
                  });
            case 3 : 
                var partial_arg = flow[0];
                return (function (param) {
                    return execPar(partial_arg, param);
                  });
            
          }
        }
      };
      var execCondStep = function (cond, left, right, data) {
        var match = Curry._2(Domain1[/* evalPredicate */4], cond, data);
        var fl = match ? left : right;
        return execFlow(fl)(data);
      };
      var execSeq = function (left, right, data) {
        return Infix$Iconixfw.$great$great$eq(execFlow(left)(data), execFlow(right));
      };
      var execPar = function (flows, data) {
        return Curry._1(Domain1[/* fold */6], execFlowList(flows, data));
      };
      var execFlowList = function (flowList, data) {
        return List.map((function (__x) {
                      return execFlow(__x)(data);
                    }), flowList);
      };
      var exec = function (instance, data) {
        return execFlow(instance[1])(data);
      };
      var runnerGet = function (def) {
        var maybe = instantiate(def);
        return Belt_Option.map(maybe, exec);
      };
      var run = function (def, data) {
        var maybe = runnerGet(def);
        var x = Belt_Option.map(maybe, (function (runFunc) {
                return Curry._1(runFunc, data);
              }));
        if (x !== undefined) {
          return Caml_option.valFromOption(x);
        } else {
          return Types$Iconixfw.freject("Unknown error");
        }
      };
      var First = /* module */[
        /* defmapper */defmapper,
        /* instantiate */instantiate,
        /* tap */tap,
        /* ftap */ftap,
        /* beforeHook */beforeHook,
        /* afterHook */afterHook,
        /* execStep */execStep,
        /* execFlow */execFlow,
        /* execCondStep */execCondStep,
        /* execSeq */execSeq,
        /* execPar */execPar,
        /* execFlowList */execFlowList,
        /* exec */exec,
        /* runnerGet */runnerGet,
        /* run */run
      ];
      var partial_arg$1 = Domain2[/* mapper */5];
      var defmapper$1 = function (param) {
        return DefMapper$Iconixfw.mapDefinition(partial_arg$1, param);
      };
      var instantiate$1 = function (def) {
        var maybe = Parser$Iconixfw.FlowParser[/* parseDefinition */13](def);
        return Belt_Option.map(maybe, defmapper$1);
      };
      var tap$1 = function (f, x) {
        Curry._1(f, x);
        return x;
      };
      var ftap$1 = function (f, futval) {
        return Infix$Iconixfw.$less$$great(futval, (function (param) {
                      Curry._1(f, param);
                      return param;
                    }));
      };
      var beforeHook$1 = function (name) {
        var partial_arg = Curry._1(Domain2[/* tapStepBefore */1], name);
        return (function (param) {
            Curry._1(partial_arg, param);
            return param;
          });
      };
      var afterHook$1 = function (name) {
        var partial_arg = Curry._1(Domain2[/* tapStepAfter */2], name);
        return (function (param) {
            return Infix$Iconixfw.$less$$great(param, (function (param) {
                          return tap$1(partial_arg, param);
                        }));
          });
      };
      var execStep$1 = function (name, stepFunc, data) {
        var partial_arg = Curry._1(Domain2[/* tapStepAfter */2], name);
        var partial_arg$1 = Curry._1(Domain2[/* tapStepBefore */1], name);
        return (function (param) {
                    return ftap$1(partial_arg, param);
                  })(Curry._1(stepFunc, (function (param) {
                            return tap$1(partial_arg$1, param);
                          })(data)));
      };
      var execFlow$1 = function (flow) {
        if (typeof flow === "number") {
          return Types$Iconixfw.fresolve;
        } else {
          switch (flow.tag | 0) {
            case 0 : 
                var s = flow[1];
                var name = flow[0];
                return (function (param) {
                    return execStep$1(name, s, param);
                  });
            case 1 : 
                var right = flow[2];
                var left = flow[1];
                var cond = flow[0];
                return (function (param) {
                    return execCondStep$1(cond, left, right, param);
                  });
            case 2 : 
                var right$1 = flow[1];
                var left$1 = flow[0];
                return (function (param) {
                    return execSeq$1(left$1, right$1, param);
                  });
            case 3 : 
                var partial_arg = flow[0];
                return (function (param) {
                    return execPar$1(partial_arg, param);
                  });
            
          }
        }
      };
      var execCondStep$1 = function (cond, left, right, data) {
        var match = Curry._2(Domain2[/* evalPredicate */4], cond, data);
        var fl = match ? left : right;
        return execFlow$1(fl)(data);
      };
      var execSeq$1 = function (left, right, data) {
        return Infix$Iconixfw.$great$great$eq(execFlow$1(left)(data), execFlow$1(right));
      };
      var execPar$1 = function (flows, data) {
        return Curry._1(Domain2[/* fold */6], execFlowList$1(flows, data));
      };
      var execFlowList$1 = function (flowList, data) {
        return List.map((function (__x) {
                      return execFlow$1(__x)(data);
                    }), flowList);
      };
      var exec$1 = function (instance, data) {
        return execFlow$1(instance[1])(data);
      };
      var runnerGet$1 = function (def) {
        var maybe = instantiate$1(def);
        return Belt_Option.map(maybe, exec$1);
      };
      var run$1 = function (def, data) {
        var maybe = runnerGet$1(def);
        var x = Belt_Option.map(maybe, (function (runFunc) {
                return Curry._1(runFunc, data);
              }));
        if (x !== undefined) {
          return Caml_option.valFromOption(x);
        } else {
          return Types$Iconixfw.freject("Unknown error");
        }
      };
      var Second = /* module */[
        /* defmapper */defmapper$1,
        /* instantiate */instantiate$1,
        /* tap */tap$1,
        /* ftap */ftap$1,
        /* beforeHook */beforeHook$1,
        /* afterHook */afterHook$1,
        /* execStep */execStep$1,
        /* execFlow */execFlow$1,
        /* execCondStep */execCondStep$1,
        /* execSeq */execSeq$1,
        /* execPar */execPar$1,
        /* execFlowList */execFlowList$1,
        /* exec */exec$1,
        /* runnerGet */runnerGet$1,
        /* run */run$1
      ];
      var link = function (spec1, spec2, domMapper, data) {
        return Infix$Iconixfw.$great$great$eq(Infix$Iconixfw.$less$$great(run(spec1, data), domMapper), (function (param) {
                      return run$1(spec2, param);
                    }));
      };
      return /* module */[
              /* First */First,
              /* Second */Second,
              /* link */link
            ];
    });
}

exports.mapMaybe = mapMaybe;
exports.logPre = logPre;
exports.logPost = logPost;
exports.Make = Make;
exports.MakeLink = MakeLink;
/* Infix-Iconixfw Not a pure module */
